{
  "entityType" : "WIDGET_TYPE",
  "entity" : {
    "fqn" : "chat4",
    "name" : "chat4",
    "deprecated" : false,
    "image" : null,
    "description" : null,
    "descriptor" : {
      "type" : "timeseries",
      "sizeX" : 8,
      "sizeY" : 5,
      "resources" : [ ],
      "templateHtml" : "<div class=\"chat-container\">\r\n  <div class=\"chat-list\">\r\n    <div *ngFor=\"let msg of chatlist\" class=\"chat-row\" [ngClass]=\"msg.role === 'user' ? 'me' : 'bot'\">\r\n      <div class=\"bubble\">\r\n        <div class=\"meta\">\r\n          <span class=\"nick\">{{ msg.role === 'user' ? 'Yo' : (msg.nick || 'Bot') }}</span>\r\n          <small class=\"ts\">{{ (msg.ts || 0) | date:'yyyy-MM-dd HH:mm:ss' }}</small>\r\n        </div>\r\n        <div class=\"text\">{{ msg.content }}</div>\r\n      </div>\r\n    </div>\r\n  </div>\r\n\r\n  <div class=\"chat-input\">\r\n    <textarea [(ngModel)]=\"content\" (keydown)=\"onKeyDown($event)\" placeholder=\"Escribí un mensaje…\" rows=\"1\"></textarea>\r\n    <button (click)=\"sendMsg()\" class=\"send\">Enviar</button>\r\n  </div>\r\n</div>\r\n",
      "templateCss" : ":root {\r\n  --bg-me: #DCF8C6;            /* verde claro tipo WhatsApp */\r\n  --fg-me: #111;\r\n  --bg-bot: #2a2f3a;           /* gris oscuro */\r\n  --fg-bot: #fff;\r\n  --border: rgba(0,0,0,.12);\r\n}\r\n\r\n.chat-container{\r\n  width:100%; height:100%;\r\n  display:flex; flex-direction:column;\r\n}\r\n\r\n.chat-list{\r\n  flex:1; overflow:auto; padding:12px;\r\n  display:flex; flex-direction:column; gap:8px;\r\n}\r\n\r\n.chat-row{ display:flex; }\r\n.chat-row.me{ justify-content:flex-end; }\r\n.chat-row.bot{ justify-content:flex-start; }\r\n\r\n.bubble{\r\n  max-width:75%;\r\n  padding:10px 12px; border-radius:14px;\r\n  box-shadow: 0 1px 2px rgba(0,0,0,.08);\r\n}\r\n.chat-row.me .bubble{\r\n  background:var(--bg-me); color:var(--fg-me);\r\n  border-top-right-radius:4px;\r\n}\r\n.chat-row.bot .bubble{\r\n  background:var(--bg-bot); color:var(--fg-bot);\r\n  border-top-left-radius:4px;\r\n}\r\n\r\n.meta{\r\n  display:flex; gap:8px; align-items:center;\r\n  font-size:12px; opacity:.8; margin-bottom:4px;\r\n}\r\n.nick{ font-weight:600; }\r\n.text{ white-space:pre-wrap; word-break:break-word; }\r\n\r\n.chat-input{\r\n  display:flex; gap:8px; align-items:flex-end;\r\n  padding:10px; border-top:1px solid var(--border);\r\n}\r\n.chat-input textarea{\r\n  flex:1; resize:none; min-height:40px; max-height:140px;\r\n  padding:10px 12px; border-radius:10px; outline:none;\r\n  border:1px solid var(--border); background:transparent;\r\n  color:inherit; font:inherit;\r\n}\r\n.chat-input .send{\r\n  padding:10px 14px; border-radius:10px;\r\n  border:1px solid var(--border);\r\n  background:rgba(0,0,0,.06); color:inherit; cursor:pointer;\r\n}\r\n.chat-input .send:hover{ filter:brightness(1.1); }\r\n",
      "controllerScript" : "/****************************************************************************\r\n * Chat persistente (USER → TS key: \"chat\")\r\n * - Carga historial SOLO al abrir el dashboard (una vez)\r\n * - Luego NO hace polling; escucha actualizaciones del datasource en vivo\r\n ***************************************************************************/\r\n\r\nself.onInit = function () {\r\n  const s = self.ctx.$scope;\r\n\r\n  // ======= Config =======\r\n  const KEY = 'chat';                        // clave de timeseries del chat\r\n  const LOOKBACK_MS = 1000 * 60 * 60 * 24 * 30; // 30 días de historial\r\n  const HISTORY_LIMIT = 1000;                // tope de mensajes que mantenemos\r\n\r\n  s.content = '';\r\n  s.chatlist = [];\r\n  let userId = null;\r\n  let lastTs = 0; // último timestamp renderizado\r\n\r\n  // ======= Utilidades =======\r\n  function token() { return localStorage.getItem('jwt_token'); }\r\n  function getUserId() {\r\n    const cu = self.ctx.currentUser || {};\r\n    return (cu?.userId?.id || cu?.userId) || null;\r\n  }\r\n  function scrollBottom() {\r\n    const cont = self.ctx.$container && self.ctx.$container[0].querySelector('.chat-list');\r\n    if (cont) cont.scrollTop = cont.scrollHeight;\r\n  }\r\n  function parseMsg(ts, val) {\r\n    let msg = null;\r\n    if (typeof val === 'string') {\r\n      try { msg = JSON.parse(val); } catch { msg = { role: 'system', content: String(val) }; }\r\n    } else if (val && typeof val === 'object') {\r\n      msg = val;\r\n    }\r\n    if (!msg) return null;\r\n    msg.ts = msg.ts || ts;\r\n    if (!msg.role) {\r\n      msg.role = (msg.userId && userId && msg.userId == userId) ? 'user' : 'assistant';\r\n    }\r\n    return msg;\r\n  }\r\n  function mergeAndRender(newMsgs) {\r\n    if (!newMsgs || !newMsgs.length) return;\r\n    const keyOf = (m) => `${m.ts}|${m.role}|${m.content}`;\r\n    const map = new Map();\r\n    [...s.chatlist, ...newMsgs].forEach(m => map.set(keyOf(m), m));\r\n    s.chatlist = Array.from(map.values()).sort((a,b) => (a.ts||0)-(b.ts||0)).slice(-HISTORY_LIMIT);\r\n    lastTs = s.chatlist.length ? (s.chatlist[s.chatlist.length-1].ts||0) : 0;\r\n    self.ctx.detectChanges();\r\n    setTimeout(scrollBottom, 0);\r\n  }\r\n\r\n  // ======= REST: traer historial una sola vez (al abrir) =======\r\n  function fetchInitialHistory() {\r\n    const end = Date.now();\r\n    const start = end - LOOKBACK_MS;\r\n    const url = `/api/plugins/telemetry/USER/${userId}/values/timeseries` +\r\n                `?keys=${encodeURIComponent(KEY)}&startTs=${start}&endTs=${end}` +\r\n                `&limit=${HISTORY_LIMIT}&agg=NONE`;\r\n    return self.ctx.http.get(url, {\r\n      headers: { 'X-Authorization': 'Bearer ' + token() }\r\n    }).subscribe(\r\n      (resp) => {\r\n        const arr = (resp && resp[KEY]) ? resp[KEY] : [];\r\n        const msgs = [];\r\n        for (let i=0;i<arr.length;i++) {\r\n          const m = parseMsg(arr[i].ts, arr[i].value);\r\n          if (m) msgs.push(m);\r\n        }\r\n        mergeAndRender(msgs);\r\n      },\r\n      (e) => console.error('Error cargando historial inicial:', e)\r\n    );\r\n  }\r\n\r\n  // ======= Enviar mensaje: guarda telemetría (sin esperar a REST) =======\r\n  s.sendMsg = function () {\r\n    const text = (s.content || '').trim();\r\n    if (!text) return;\r\n    if (text.length > 2000) { console.warn('Mensaje muy largo (>2000).'); return; }\r\n\r\n    const cu = self.ctx.currentUser || {};\r\n    const nick = [cu.firstName || '', cu.lastName || ''].join(' ').trim() || cu.name || cu.email || 'Yo';\r\n    const ts = Date.now();\r\n    const msg = { role: 'user', userId, nick, content: text, ts };\r\n    const body = [{ ts, values: { [KEY]: JSON.stringify(msg) } }];\r\n\r\n    self.ctx.http.post(\r\n      `/api/plugins/telemetry/USER/${userId}/timeseries/ANY`,\r\n      body,\r\n      { headers: { 'content-type': 'application/json', 'X-Authorization': 'Bearer ' + token() } }\r\n    ).subscribe(\r\n      () => {\r\n        s.content = '';\r\n        // Optimista: lo muestro ya. El datasource en vivo también lo traerá.\r\n        mergeAndRender([msg]);\r\n      },\r\n      (err) => console.error('Error enviando chat:', err)\r\n    );\r\n  };\r\n\r\n  // Enter = enviar ; Shift+Enter = salto de línea\r\n  s.onKeyDown = function (ev) {\r\n    if (ev.key === 'Enter' && !ev.shiftKey) {\r\n      ev.preventDefault();\r\n      s.sendMsg();\r\n    }\r\n  };\r\n\r\n  // ======= Boot =======\r\n  userId = getUserId();\r\n  if (!userId) { console.error('userId no disponible'); return; }\r\n  fetchInitialHistory(); // <-- SOLO una vez al abrir\r\n};\r\n\r\n// IMPORTANTE: acá NO pedimos historial otra vez.\r\n// Solo integramos lo que llegue del datasource (realtime) y NO borramos si viene vacío.\r\nself.onDataUpdated = function () {\r\n  const s = self.ctx.$scope;\r\n  const ds = (self.ctx.data && self.ctx.data[0] && self.ctx.data[0].data) ? self.ctx.data[0].data : [];\r\n  if (!ds.length) return; // no resetear si no hay puntos en esta ventana\r\n\r\n  const rows = [];\r\n  for (let i = 0; i < ds.length; i++) {\r\n    const ts = ds[i][0];\r\n    const val = ds[i][1];\r\n    const m = (function(){\r\n      if (typeof val === 'string') { try { return JSON.parse(val); } catch { return { role:'system', content:String(val) }; } }\r\n      if (val && typeof val === 'object') return val;\r\n      return null;\r\n    })();\r\n    if (m) { m.ts = m.ts || ts; rows.push(m); }\r\n  }\r\n  // Podrían venir también mensajes ya cargados: hacemos merge + dedupe\r\n  mergeAndRender(rows);\r\n\r\n  function mergeAndRender(list) {\r\n    const keyOf = (m) => `${m.ts}|${m.role}|${m.content}`;\r\n    const map = new Map();\r\n    [...(s.chatlist||[]), ...list].forEach(m => map.set(keyOf(m), m));\r\n    s.chatlist = Array.from(map.values()).sort((a,b)=> (a.ts||0)-(b.ts||0)).slice(-1000);\r\n    self.ctx.detectChanges();\r\n    setTimeout(() => {\r\n      const cont = self.ctx.$container && self.ctx.$container[0].querySelector('.chat-list');\r\n      if (cont) cont.scrollTop = cont.scrollHeight;\r\n    }, 0);\r\n  }\r\n};\r\n\r\nself.typeParameters = function () {\r\n  return { maxDatasources: 1, maxDataKeys: 1, minDataKeys: 1 };\r\n};\r\n",
      "settingsForm" : [ ],
      "dataKeySettingsForm" : [ ],
      "defaultConfig" : "{\"datasources\":[{\"type\":\"function\",\"name\":\"function\",\"dataKeys\":[{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"First\",\"color\":\"#2196f3\",\"settings\":{\"showLines\":true,\"fillLines\":true,\"showPoints\":false},\"_hash\":0.8587686344902596,\"funcBody\":\"var value = prevValue + Math.random() * 100 - 50;\\nvar multiplier = Math.pow(10, 2 || 0);\\nvar value = Math.round(value * multiplier) / multiplier;\\nif (value < -1000) {\\n\\tvalue = -1000;\\n} else if (value > 1000) {\\n\\tvalue = 1000;\\n}\\nreturn value;\"},{\"name\":\"f(x)\",\"type\":\"function\",\"label\":\"Second\",\"color\":\"#ffc107\",\"settings\":{\"showLines\":true,\"fillLines\":false,\"showPoints\":false},\"_hash\":0.12775350966079668,\"funcBody\":\"var value = prevValue + Math.random() * 100 - 50;\\nvar multiplier = Math.pow(10, 2 || 0);\\nvar value = Math.round(value * multiplier) / multiplier;\\nif (value < -1000) {\\n\\tvalue = -1000;\\n} else if (value > 1000) {\\n\\tvalue = 1000;\\n}\\nreturn value;\"}]}],\"timewindow\":{\"realtime\":{\"timewindowMs\":60000}},\"showTitle\":true,\"backgroundColor\":\"#fff\",\"color\":\"rgba(0, 0, 0, 0.87)\",\"padding\":\"8px\",\"settings\":{\"shadowSize\":4,\"fontColor\":\"#545454\",\"fontSize\":10,\"xaxis\":{\"showLabels\":true,\"color\":\"#545454\"},\"yaxis\":{\"showLabels\":true,\"color\":\"#545454\"},\"grid\":{\"color\":\"#545454\",\"tickColor\":\"#DDDDDD\",\"verticalLines\":true,\"horizontalLines\":true,\"outlineWidth\":1},\"legend\":{\"show\":true,\"position\":\"nw\",\"backgroundColor\":\"#f0f0f0\",\"backgroundOpacity\":0.85,\"labelBoxBorderColor\":\"rgba(1, 1, 1, 0.45)\"},\"decimals\":1,\"stack\":false,\"tooltipIndividual\":false},\"title\":\"chat4\",\"dropShadow\":true,\"enableFullscreen\":true,\"titleStyle\":{\"fontSize\":\"16px\",\"fontWeight\":400},\"mobileHeight\":null}"
    },
    "externalId" : null,
    "resources" : null,
    "id" : {
      "entityType" : "WIDGET_TYPE",
      "id" : "44dc12e0-8baa-11f0-8d0c-9de3d92fa448"
    },
    "scada" : false,
    "tags" : null
  },
  "relations" : [ ],
  "attributes" : {
    "SERVER_SCOPE" : [ ]
  }
}